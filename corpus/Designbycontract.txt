design by contract dbc also known as contract programming programming by contract and design-by-contract programming is an approach for designing software it prescribes that software designers should define formal precise and verifiable interface specifications for software components which extend the ordinary definition of abstract data types with preconditions postconditions and invariants these specifications are referred to as contracts in accordance with a conceptual metaphor with the conditions and obligations of business contracts
the dbc approach assumes all client components that invoke an operation on a server component will meet the preconditions specified as required for that operation where this assumption is considered too risky as in multi-channel client-server or distributed computing the opposite defensive design approach is taken meaning that a server component tests before or while processing a client's request that all relevant preconditions hold true and replies with a suitable error message if not


the term was coined by bertrand meyer in connection with his design of the eiffel programming language and first described in various articles starting in 1986 and the two successive editions 1988 1997 of his book object-oriented software construction eiffel software applied for trademark registration for design by contract in december 2003 and it was granted in december 2004 the current owner of this trademark is eiffel software
design by contract has its roots in work on formal verification formal specification and hoare logic the original contributions include
the central idea of dbc is a metaphor on how elements of a software system collaborate with each other on the basis of mutual obligations and benefits the metaphor comes from business life where a client and a supplier agree on a contract that defines for example that
similarly if a routine from a class in object-oriented programming provides a certain functionality it may
the contract is semantically equivalent to a hoare triple which formalises the obligations this can be summarised by the three questions that the designer must repeatedly answer in the contract
many programming languages have facilities to make assertions like these however dbc considers these contracts to be so crucial to software correctness that they should be part of the design process in effect dbc advocates writing the assertions first contracts can be written by code comments enforced by a test suite or both even if there is no special language support for contracts
the notion of a contract extends down to the methodprocedure level the contract for each method will normally contain the following pieces of informationcitation needed
subclasses in an inheritance hierarchy are allowed to weaken preconditions but not strengthen them and strengthen postconditions and invariants but not weaken them these rules approximate behavioural subtyping
all class relationships are between client classes and supplier classes a client class is obliged to make calls to supplier features where the resulting state of the supplier is not violated by the client call subsequently the supplier is obliged to provide a return state and data that does not violate the state requirements of the client for instance a supplier data buffer may require that data is present in the buffer when a delete feature is called subsequently the supplier guarantees to the client that when a delete feature finishes its work the data item will indeed be deleted from the buffer other design contracts are concepts of class invariant the class invariant guarantees for the local class that the state of the class will be maintained within specified tolerances at the end of each feature execution
when using contracts a supplier should not try to verify that the contract conditions are satisfied the general idea is that code should fail hard with contract verification being the safety net dbc's fail hard property simplifies the debugging of contract behavior as the intended behaviour of each routine is clearly specified this distinguishes it markedly from a related practice known as defensive programming where the supplier is responsible for figuring out what to do when a precondition is broken more often than not the supplier throws an exception to inform the client that the precondition has been broken and in both cases—dbc and defensive programming—the client must figure out how to respond to that dbc makes the supplier's job easier
design by contract also defines criteria for correctness for a software module
design by contract can also facilitate code reuse since the contract for each piece of code is fully documented the contracts for a module can be regarded as a form of software documentation for the behavior of that module
contract conditions should never be violated during execution of a bug-free program contracts are therefore typically only checked in debug mode during software development later at release the contract checks are disabled to maximize performance
in many programming languages contracts are implemented with assert asserts are by default compiled away in release mode in cc++ and similarly deactivated in c# and java this effectively eliminates the run-time costs of contracts in release
design by contract does not replace regular testing strategies such as unit testing integration testing and system testing rather it complements external testing with internal self-tests that can be activated both for isolated tests and in production code during a test-phase the advantage of internal self-tests is that they can detect errors before they manifest themselves as invalid results observed by the client this leads to earlier and more specific error detection
languages that implement most dbc features natively include
various libraries preprocessors and other tools have been developed for existing programming languages without native design by contract support
